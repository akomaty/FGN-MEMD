function [B,x,eta] = Vfbm(M,H,rho,eta) ;% function [B,x,w] = Vfbm(M,H,rho,eta) ;% Multivariate Fractional Brownian motion sythesis with circulant matrix method%% if eta is not specified, we ask for the well-balanced case or the causal% case. According to the reference below, we test for the validity of the% model (we alert if the model is not valid), and we test for the exactness% of the simulation (we alert if the simulation is not exact).%% Inputs:%          M : number of samples%          H : Hurst parameter (0 < H < 1);%              H is a vector of dimension p.%          rho : covariance matrix (!! not the correlation)%          eta :  second parameter (should be antisymmetric)% Outputs:%          B : H-fBm (p*M)-length trace%          x : H-fGn : x[n] = B[n+1] - B[n]%         %% PO Amblard&JF Coeurjolly% see PO Amblard, JF Coeurjolly, F. Lavancier, A. Philippe, Basic% properties of the multivariate fractional Brownian motion,% ArXiv:1007.0828v1,Bull. Soc. Math. France 2012. p=max(size(H));N=2^nextpow2(M);n = 0:N-1;q=2:N-1;l=[N+1:(2*N-2)]-2*N;nlogn=[0 2*log(2) (q-1).*log(abs(q-1))-2.*q.*log(abs(q))+(q+1).*log(abs(q+1))];nlogn=[nlogn 0 (l-1).*log(abs(l-1))-2.*l.*log(abs(l))+(l+1).*log(abs(l+1)) 2*log(2)];deltan=[2 zeros(1,2*N-1)];sigma=sqrt(diag(rho));rho=diag(1./sigma)*rho*(diag(1./sigma));if nargin==3    cas=2;    while ~((cas==0)|(cas==1))        %cas=input('well-balanced (0) or causal (1)?');        cas=0;    end    eta=zeros(p,p);    if cas==1        for i=1:p;            for j=i+1:p;                if (H(i)+H(j)==1)                    eta(i,j)=rho(i,j)*2/tan(pi*H(i))/pi;                else                    eta(i,j)=-rho(i,j)*tan(pi/2*(H(i)+H(j)))*tan(pi/2*(H(i)-H(j)));                end                eta(j,i)=-eta(i,j);            end        end    endend% TESTING THE VALIDITY OF THE MODEL (see prop. 9 in the above reference)test=0;q=zeros(p,p);for i=1:p;    for j=1:p        if (H(i)+H(j)==1)            q(i,j)=rho(i,j)-sqrt(-1)*pi/2*eta(i,j);        else            q(i,j)=rho(i,j)*sin(pi/2*(H(i)+H(j)))-sqrt(-1)*eta(i,j)*cos(pi/2*(H(i)+H(j)));        end        q(i,j)=q(i,j)*gamma(H(i)+H(j)+1);    endend[v,d]=eig(q);test=sum(diag(d)<0);if (test==1)    display('The model is not well defined');end% Embedding the covariance of the fGn in the circulant matrix % and calculation of the eigen valuesa=zeros(p,p,2*N);n=[ n N -fliplr(n(2:end))];for i=1:p    for j=i:p                if (H(i)+H(j)==1)            r=.5*( rho(i,j)*deltan+eta(i,j)*nlogn);                  else            r= (rho(i,j)-eta(i,j)*sign(n-1)).*abs(n-1).^(H(i)+H(j)) ;            r=r-2*(rho(i,j)-eta(i,j)*sign(n)).*abs(n).^(H(i)+H(j) )  ;            r=.5*(r+(rho(i,j)-eta(i,j)*sign(n+1)).*abs(n+1).^(H(i)+H(j)) );            r(N+1)= .5*(rho(i,j)+rho(j,i))*( abs(N-1).^(H(i)+H(j))-2*abs(N).^(H(i)+H(j) )+abs(N+1).^(H(i)+H(j) ) );        end        a(i,j,:)=fft(r) ;        a(j,i,:)=conj(a(i,j,:));    endend% diagonalisation, white noise generation, filteringw=fft(randn(p,2*N)').';flag=0;%test for pos-def of matrices afor k=1:2*N    [v,d]=eig(squeeze(a(:,:,k)));     [i,j]=find(diag(d)<0);    flag=(flag|(~isempty(i)));    d=diag( max([diag(d)' ; zeros(1,p)]));    W(:,k)=v*sqrt(d)*v'*w(:,k);endif (flag==1)    display('The simulation is not exact')endz = ifft(W.')' ;size(z);size(sigma);x = diag(sigma)*z(:,1:M) ;%x = z(:,1:M) ;B = cumsum(x')' ;